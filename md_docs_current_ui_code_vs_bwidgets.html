<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>bWidgets: Blender UI Code Issues</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">bWidgets
   </div>
   <div id="projectbrief">Core widget toolkit designed for Blender</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_docs_current_ui_code_vs_bwidgets.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Blender UI Code Issues </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p >Which problems does the current Blender widget code have and how does bWidgets try to solve them?</p>
<p >With bWidgets we try to solve a number of issues the current Blender UI code has. The following sections describe some of these issues and how bWidgets tries to address them.</p>
<hr  />
<p> <b>Note</b></p>
<p ><em>At this point bWidgets is limited to drawing and some very basic handling. Hence, much of the issues mentioned here are not addressed yet, but bWidgets is designed to do so from the ground up.</em></p>
<hr  />
<h1><a class="anchor" id="general_design"></a>
General Design</h1>
<h2>There is none (almost)</h2>
<p >Aside from a general MVC approach (which is broken in many places), the Blender interface code as a whole doesn't really follow any design ideas. "Just make it
work" is the route it takes. Granted, this may not necessarily be bad, and after all this code worked for many years; however, it became a big mass of spaghetti code that is hard to maintain, extend and understand.</p>
<p >bWidgets does have a far more defined design. It sticks to using MVC and it is much more strict in applying it. Further, it incorporates useful abstractions to clearly separate different parts of the code. That alone adds another level of flexibility. <br  />
 For more information, check the [design overview] (<a class="el" href="md_docs_bWidgets_design_overview.html">Design Overview</a>).</p>
<h2>"Wannabe-generic" data-structures</h2>
<p >The central widget related data-structures (e.g. <code>uiBlock</code>, <code>uiBut</code>, <code>uiHandleButtonData</code>) try to be one-size-fits-all designs. All widgets use exactly these structures, even though they need to store completely different data. Hacks are used to get variables to work for multiple widget-types, even if the needed data-type differs. Examples are the <a href="https://developer.blender.org/diffusion/B/browse/master/source/blender/editors/interface/interface_intern.h;1dafe759edc3bc9a89f99a894d1c1fb3a14f44a9$224-243"><code>uiBut.a1</code> and <code>uiBut.a2</code> fields</a>, or <a href="https://developer.blender.org/diffusion/B/browse/master/source/blender/editors/include/UI_interface.h;1dafe759edc3bc9a89f99a894d1c1fb3a14f44a9$229-245"><code>uiBut.poin</code></a>. Additionally, the data-structures contain many members they only need in certain situations (e.g. for a certain button type).<br  />
 These points make the structures pretty confusing to work with and ask for trouble (and add unnecessary bytes of memory).</p>
<p >In the bWidgets design, every widget-type has its own data-structure, specifically crafted for its own needs. Data-duplication across multiple widget-types can be avoided using inheritance. The controller (speaking in MVC terminology) can implement interfaces which store custom data as needed, like RNA or operator data. Although not implemented yet, imagine it to work like this: the controller registers a handler object for widgets (e.g. <code>uiRNAStringHandler</code> or <code>uiOperatorHandler</code>), that stores its own data and gets notified on state changes.</p>
<h2>Tight coupling of data and modules</h2>
<p >The Blender UI code is built really tightly around the Blender data systems, much closer than healthy. There are calls to DNA and RNA everywhere. Different modules are also mixed, the UI code does many Blender-kernel or window-manager calls. Such tight coupling of data and modules provokes problems:</p><ul>
<li>Changes in one module might affect the functioning of the others.</li>
<li>Refactoring or even replacing single modules becomes really hard.</li>
<li>Code becomes a lot more confusing.</li>
</ul>
<p >Making the code more modular and adding reasonable abstractions should help here.</p>
<p >bWidgets would not know anything about Blender's internal data systems. In its design, widgets are more like blackboxes, manufactured to represent more complex data with primitive tools. They only know about strings, numeric-values, color values, etc. The controller (in MVC terms) manages the application specific data manipulations (e.g. updating DNA through RNA).</p>
<h2>Unconventional/unfitting "design"</h2>
<p >It is general consensus that widget/GUI toolkits benefit from object-oriented designs. There are many different kinds of GUI elements and there is lots of overlap between them. Such overlap can be managed nicely using object-oriented-programming (OOP) inheritance in code. Encapsulation and abstraction are useful to ensure valid states (often through <em>manager</em>-objects and the like), maintainability and great flexibility. Blender doesn't follow any of these conventions, even though they seem to be very reasonable. <br  />
 For new programmers, this adds another hurdle, since they are used to entirely different designs.</p>
<p ><em>Note that this point is not about programming languages: GTK+ (a widely used widget toolkit) is written in C, but tries to emulate OOP features as much as possible. However an OOP-based language should still be better suited.</em></p>
<p >The design of bWidgets is based on these conventions and should be able to gain from their benefits. It also uses C++ which has OOP features builtin.</p>
<h1><a class="anchor" id="limitations"></a>
Limitations</h1>
<h2>Unit-/Regression-testing</h2>
<p >No part of the Blender UI code is unit-tested as of now. Because of the tight coupling of modules and data, it's just not easy to do. A unit-test can't simply create a widget to test some of its functionality, a big part of the widget pipeline would have to be involved. Or at least, only very few units can be tested in a useful manner. <br  />
 Neither is there a way to render the GUI or parts of it (individual widgets) into an image. Such images would be useful for regression-tests, for example in the layout- or theme-system.</p>
<p >bWidgets addresses this as follows:</p><ul>
<li>Unit-tests are part of the bWidgets feature set.</li>
<li>Widgets are independent from much of the widget pipeline, so individual aspects can be tested easily.</li>
<li>The paint-engine design allows to easily render individual widgets or the entire GUI into images which can be used for regression-testing.</li>
</ul>
<h2>Missing hierarchy</h2>
<p >Widgets are grouped together into blocks (<code>uiBlock</code>) in Blender. This system is not very flexible in that there is a lack of further grouping capabilities. There's no nesting of blocks. <br  />
 A hierarchical structure could bring some benefits:</p><ul>
<li>Integrate panels into widget pipeline (they act like blocks, but have drawing capabilities like widgets).</li>
<li>Better control over handling with multiple widgets involved (e.g. modifier drag &amp; drop or <a href="https://wiki.blender.org/index.php/Dev:Ref/Release_Notes/2.70/UI#Multi-Number_Button_Editing"><em>multi-number button editing</em></a>).</li>
<li>Add a real relation between buttons and popups (e.g. the button to invoke a menu would be the parent of the menu). Currently this relation is barely there.</li>
<li>Limit redraws (e.g. only redraw one node of the tree).</li>
<li>Faster lookups (e.g. use bounding-box of grouped widgets when trying to find hovered widget).</li>
<li>Better and easier debugging (debugging can be limited to a specific part of the tree, plus the tree can be visualized or printed to stdout).</li>
<li>Replace <code>uiBlock</code> with case specific data-structures.</li>
</ul>
<p >On the downside, hierarchical or tree structures are harder to work with than linear lists, thus it's easier to make mistakes. We can unit-test hierarchies nicely though.</p>
<p >In bWidgets we could do what Qt does: Widgets can have child widgets, whereby each parent widget is responsible for managing the layout of its children. In most cases, the parent widget would ask the layout system to do needed calculations.</p>
<h1><a class="anchor" id="widget_handling"></a>
Widget Handling (User Input Code)</h1>
<h2>Welcome to hell - <code>interface_handlers.c</code></h2>
<p >Most GUI interaction code is placed in <a href="https://developer.blender.org/diffusion/B/browse/master/source/blender/editors/interface/interface_handlers.c"><code>interface_handerls.c</code></a>, a 10,000+ lines beast. It's really hard to navigate in such a file, though the file size by far isn't the only problem (that alone would be easy to solve):</p><ul>
<li>Different levels of code are mixed everywhere.</li>
<li>Mixed handling of entire areas, widgets, popups, text-editing, tooltips, etc.</li>
<li>Contains lots of functions that don't belong there (e.g. context-menu population, see <a href="https://developer.blender.org/diffusion/B/browse/master/source/blender/editors/interface/interface_handlers.c;00d2dfa93ae8a84b163930246709c50b8ee1e148$6763-7077"><code>ui_but_menu()</code></a>).</li>
<li>Thousands of exceptions for countless special cases.</li>
<li>Data management is mixed with low-level event handling everywhere.</li>
<li>State changes are hard to follow and predict.</li>
<li>...</li>
</ul>
<h2>Confusing Popup Handling</h2>
<p >Popup handling is part of <code>interface_handlers.c</code> and suffers from the same issues. It still deserves special mention though:</p><ul>
<li>The popup state is especially hard to predict and follow. It's based on return values which get passed through multiple levels of recursion (and some temporary data-structures)</li>
<li>Context gets temporarily changed.</li>
<li>Code jumps from special menu handling to regular button handling multiple times.</li>
<li>...</li>
</ul>
<p >If you want to get a taste of it, have a look at <a href="https://developer.blender.org/diffusion/B/browse/master/source/blender/editors/interface/interface_handlers.c;a3409d3f53f1decb3cbe5c04fd804062dcf2cf49$9877-9974"><code>ui_handle_menus_recursive()</code></a>, or the gorgeous <a href="https://developer.blender.org/diffusion/B/browse/master/source/blender/editors/interface/interface_handlers.c;a3409d3f53f1decb3cbe5c04fd804062dcf2cf49$9057-9492"><code>ui_handle_menu_event()</code></a>.</p>
<p >For bWidgets we plan to have something like a popup-manager to take over high-level popup handling. Using the hierarchical widget storage described earlier, proper relations can be established that make the execution easier to follow. We may also add some internal UI-context to bWidgets for managing states. All these changes should split the popup handling into smaller, more manageable parts.</p>
<h1><a class="anchor" id="theme_system"></a>
Theme System</h1>
<h2>Limited Theme Options</h2>
<p >The current theme-system only allows limited tweaks to the appearance of GUI elements. Why shouldn't it have full control over how the GUI looks? What if it had control over header sizes, widget sizes, layout margins, text alignments, radii of widget corners, the used icon set, icon sizes, widget drop-shadows, ... With the current approach to theming in Blender that's not possible, because it mainly concerns colors and every option is exposed in the UI. <a href="https://developer.blender.org/T45352">We should not expose any more theme options</a>.</p>
<p >Let's rethink theming completely. <br  />
 bWidgets has <em>Styles</em> builtin, which should eventually give full control over how widgets look. These styles can be CSS based (WIP), meaning users can edit them even if not exposed in the UI. And, they should be able to share styles online. The way they are designed, styles (and thus CSS) can affect properties outside of bWidgets too, for example header sizes.</p>
<p >Imagine a theming-system, which lets you choose from a flat, depth-based design (like <a href="https://material.io/">Google Material Design</a>), a more classic design, or even an OS-native design in Blender. And that fully customizable and with support for sharing. <br  />
 <a href="https://www.gnome-look.org/browse/cat/135/">GTK+ is a great example of such flexibility</a> <br  />
 Eventually, styles should be able to completely override the drawing (and handling) of widgets. For example a theme/style could make Blender's unconventional number-widgets use a conventional design for those who want it.</p>
<p >There is another big benefit to take from such a flexible styling system: UIs for usage in virtual reality worlds could be just another style. A style that makes buttons bigger, easier to read and easier to operate via handheld controllers.</p>
<h2>Themes can't inherit nicely</h2>
<p >Depending on where widgets are drawn, they may need to use different theme colors. Blender's push-buttons (to execute an operator) are drawn completely different when placed in a menu - and different again when placed in a pie-menu. Similarly, text colors may need adjustments when used in front of special backgrounds (see <a href="https://developer.blender.org/T48241">T48241</a>). Currently, Blender solves this with hardcoded checks for these special cases. These become hard to keep track of and maintain. Fixing problems with the hard-coded checks is no rocket-science, but we can actually get rid of them entirely.</p>
<p >A widget theming system that allows overrides based on where widgets are placed in a hierarchy would be preferable. CSS has that builtin: The <code>bwMenu &gt; bwPushButton</code> CSS selector would apply its style properties only to push-buttons that are placed directly in a menu. bWidgets could support that.</p>
<h2>XML vs. CSS for Themes</h2>
<p >Blender already supports storing and loading themes using XML. However it is a markup language, not a style-sheet language. In theory we could add all the features we need to it by adding more custom tags and properties. But all that is just emulating something that CSS is built to do. Just <a href="https://developer.blender.org/diffusion/B/browse/master/release/scripts/presets/interface_theme/flatty_light.xml">look at one of the theme files</a>, and it's obvious how it tries to mimic CSS. Designers should also be familiar with CSS, unlike some Blender specific XML usage. <br  />
</p>
<p >The CSS standards define many features we'd need for an advanced theme-system:</p><ul>
<li>Property values based on state (e.g. different color on mouse hover)</li>
<li>Property values based on hierarchy position (see previous section)</li>
<li>Margins and paddings</li>
<li>Text alignment</li>
<li>Linear gradients (no more <code>shadetop</code> and <code>shadedown</code> for widget themes)</li>
<li>Drop-shadows</li>
<li>...</li>
</ul>
<p >So we would be able to support many of the CSS standard properties, and the selectors suit our needs as well. There are CSS parsing libraries that we can use. Although we may have to write our own code to interpret the parsing result according to the standards. We can start with a small supported subset of the standards and add more features as needed. <br  />
 Work on CSS support is ongoing in the <a href="https://github.com/julianeisel/bWidgets/tree/css_styles">css_styles</a> branch. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
